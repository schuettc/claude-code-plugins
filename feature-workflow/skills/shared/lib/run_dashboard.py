#!/usr/bin/env python3
"""CLI entry point for dashboard generation.

This script can be called directly from skills or hooks:
    python3 run_dashboard.py <project_root>

It handles the import path setup needed to use the shared library.
"""

import sys
from pathlib import Path

# Add the lib directory to the Python path for imports
LIB_DIR = Path(__file__).parent
if str(LIB_DIR) not in sys.path:
    sys.path.insert(0, str(LIB_DIR))

# Now we can import the modules directly
from frontmatter import parse_frontmatter, parse_frontmatter_string
from models import FeatureStatus, FeatureContext


def generate_dashboard(project_root: Path) -> None:
    """Generate DASHBOARD.md from feature directories."""
    from datetime import datetime

    features_dir = project_root / "docs" / "features"
    dashboard_path = features_dir / "DASHBOARD.md"

    # Ensure features directory exists
    features_dir.mkdir(parents=True, exist_ok=True)

    # Collect features by status
    backlog_items: list[FeatureContext] = []
    inprogress_items: list[FeatureContext] = []
    completed_items: list[FeatureContext] = []

    # Scan feature directories
    if features_dir.exists():
        for feature_dir in sorted(features_dir.iterdir()):
            # Skip non-directories and DASHBOARD.md
            if not feature_dir.is_dir():
                continue
            if feature_dir.name == "DASHBOARD.md":
                continue

            # Parse feature context
            ctx = FeatureContext.from_directory(feature_dir)
            if ctx is None:
                continue

            # Categorize by status
            if ctx.status == FeatureStatus.COMPLETED:
                completed_items.append(ctx)
            elif ctx.status == FeatureStatus.IN_PROGRESS:
                inprogress_items.append(ctx)
            else:
                backlog_items.append(ctx)

    # Generate dashboard content
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    lines = [
        "# Feature Dashboard",
        "",
        "*Auto-generated by hooks. Do not edit directly.*",
        f"*Last updated: {timestamp}*",
        "",
        "## In Progress",
    ]

    if not inprogress_items:
        lines.append("*No features in progress*")
    else:
        lines.append("")
        lines.append("| ID | Name | Priority | Started |")
        lines.append("|----|------|----------|---------|")
        for ctx in inprogress_items:
            started = str(ctx.started) if ctx.started else ""
            lines.append(f"| [{ctx.feature_id}](./{ctx.feature_id}/) | {ctx.name} | {ctx.priority} | {started} |")

    lines.extend(["", "## Backlog"])

    # Build a lookup of all features for dependency checking
    all_features: dict[str, FeatureContext] = {}
    for ctx in backlog_items + inprogress_items + completed_items:
        all_features[ctx.feature_id] = ctx

    if not backlog_items:
        lines.append("*No features in backlog*")
    else:
        lines.append("")
        lines.append("| ID | Name | Priority | Effort | Added | Blocked By |")
        lines.append("|----|------|----------|--------|-------|------------|")
        for ctx in backlog_items:
            created = str(ctx.created) if ctx.created else ""
            # Show unmet dependencies
            unmet = ctx.has_unmet_dependencies(all_features)
            blocked_by = ", ".join(unmet) if unmet else ""
            lines.append(f"| [{ctx.feature_id}](./{ctx.feature_id}/) | {ctx.name} | {ctx.priority} | {ctx.effort} | {created} | {blocked_by} |")

    lines.extend(["", "## Completed"])

    if not completed_items:
        lines.append("*No completed features*")
    else:
        lines.append("")
        lines.append("| ID | Name | Shipped |")
        lines.append("|----|------|---------|")
        for ctx in completed_items:
            shipped = str(ctx.shipped) if ctx.shipped else ""
            lines.append(f"| [{ctx.feature_id}](./{ctx.feature_id}/) | {ctx.name} | {shipped} |")

    # Add trailing newline
    lines.append("")

    content = "\n".join(lines)

    # Write dashboard
    dashboard_path.write_text(content, encoding="utf-8")

    # Log to stderr (for hook feedback)
    print(f"[dashboard] Generated DASHBOARD.md with:", file=sys.stderr)
    print(f"  - {len(inprogress_items)} in progress", file=sys.stderr)
    print(f"  - {len(backlog_items)} in backlog", file=sys.stderr)
    print(f"  - {len(completed_items)} completed", file=sys.stderr)


def main() -> int:
    """CLI entry point."""
    if len(sys.argv) < 2:
        print("Usage: python3 run_dashboard.py <project_root>", file=sys.stderr)
        return 1

    project_root = Path(sys.argv[1])

    if not project_root.is_dir():
        print(f"Error: {project_root} is not a directory", file=sys.stderr)
        return 1

    try:
        generate_dashboard(project_root)
        return 0
    except Exception as e:
        print(f"Error generating dashboard: {e}", file=sys.stderr)
        return 1


if __name__ == "__main__":
    sys.exit(main())
